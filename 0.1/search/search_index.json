{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#phaser-the-weapon-of-choice-for-ptychographic-reconstructions","title":"phaser: The weapon of choice for ptychographic reconstructions","text":"<p><code>phaser</code> is a fully-featured package for multislice electron ptychography. See our arXiv paper for more details.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>ePIE, LSQ-MLs, and gradient descent algorithms</li> <li><code>numpy</code>, <code>cupy</code>, and <code>jax</code> backends.</li> <li>Single and multislice ptychography</li> <li>Multiple incoherent probe modes</li> <li>Probe position correction</li> <li>Upsampled (sPIE) and segmented ptychography (work in progress)</li> <li>Adaptive propagator correction (contributed by M Zhu)</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation on <code>phaser</code> can be found here: https://hexane360.github.io/phaser/dev/</p> <p>Documentation is still very much a work in progress, so please feel free to open an issue or email me if you have any questions!</p>"},{"location":"#installation","title":"Installation","text":"<p>To install, first clone the repository from github. This can be done from GitHub Desktop, or from the git command line:</p> <pre><code>$ git clone https://github.com/hexane360/phaser\n# enter phaser directory\n$ cd phaser\n</code></pre> <p>We recommend using a conda environment or Python virtual environment to keep things clean, although this is not mandatory.</p> <p><code>phaser</code> supports multiple computational backends. The simplest (and slowest) is <code>numpy</code>. <code>cupy</code> can be used for CUDA-accelerated. <code>jax</code> supports CPU and GPU acceleration, and is the only backend which supports the gradient descent engine. If you're unsure what engines to use, we recommend installing the <code>jax</code> engine.</p> <p>If you're using <code>cupy</code> or <code>jax</code> with a GPU, start by following the installation instructions for those packages. Jax can be installed with or without CUDA support, if you're using CUDA make sure you install the correct version. Currently, Jax does not support CUDA on Windows.</p> <p>Before moving on to installing <code>phaser</code>, make sure those packages you've installed work: <pre><code>$ python\n&gt;&gt;&gt; import jax\n&gt;&gt;&gt; jax.default_backend()\n'gpu'  # should be 'gpu' on cuda, 'cpu' otherwise\n&gt;&gt;&gt; jax.numpy.array([1, 2, 3, 4]) + 1   # test a basic operation\nArray([2, 3, 4, 5], dtype=int32)\n\n&gt;&gt;&gt; import cupy\n&gt;&gt;&gt; cupy.array([1, 2, 3, 4]) + 1\narray([2, 3, 4, 5])\n</code></pre></p> <p>Then, install <code>phaser</code> using <code>pip</code>:</p> <pre><code>$ python -m pip install -e .\n</code></pre> <p>For the jax or cupy backend, or for the optional webserver, install with the corresponding options:</p> <pre><code>$ python -m pip install -e \".[jax,cupy12,web]\" # for the 'jax', 'cupy12', and 'web' options\n</code></pre> <p>Depending on your command line, you may need to put double quotes around the options (as shown).</p> <p>Here are the supported installation options:</p> <ul> <li><code>jax</code>: For the <code>jax</code> backend (required for the gradient descent engine)</li> <li><code>cupy11</code>: <code>cupy</code> for CUDA toolkit 11.x</li> <li><code>cupy12</code>: <code>cupy</code> for CUDA toolkit 12.x</li> <li><code>web</code>: For the web interface</li> </ul> <p>For Optuna hyperoptimization, install it as well:</p> <pre><code>$ pip install optuna\n</code></pre>"},{"location":"#running","title":"Running","text":"<p>After installation, the <code>phaser</code> command should be available. Phaser can be run from the command line, or through a job server.</p> <p>To run a single reconstruction on the command line, call <code>phaser run &lt;file&gt;</code>, where <code>file</code> is the path to a reconstruction plan file.</p> <p>To run the webserver, call <code>phaser serve</code>. By default, the server serves on https://localhost:5050/, so navigate there in a web browser. The server interface can be used to start workers and schedule reconstruction jobs.</p> <p>To run a worker, call <code>phaser worker &lt;url&gt;</code>, where <code>url</code> is the URL of a running job server.</p>"},{"location":"#sample-data-examples","title":"Sample data &amp; Examples","text":"<p>Sample data can be downloaded from the following dropbox link: https://www.dropbox.com/scl/fo/txm3k88ubrzvt541v23ir/AL-l_m6VnGlFxzHWZSSc0TA?rlkey=8qxtwnc8cwhpff6jpr5s40y6i&amp;st=x9pbwke0&amp;dl=0</p> <p>Copy the <code>sample_data</code> directory into the root code folder.</p> <pre><code>$ curl --output sample_data.zip -L 'https://www.dropbox.com/scl/fo/txm3k88ubrzvt541v23ir/AL-l_m6VnGlFxzHWZSSc0TA?rlkey=8qxtwnc8cwhpff6jpr5s40y6i&amp;st=x9pbwke0&amp;dl=1'\n$ unzip sample_data.zip -x / -d sample_data\n</code></pre> <p>Sample data includes simulated and experimental MoS2 data, simulated and experimental Si data, and experimental PrScO3 data. After the data is downloaded, any of the example reconstructions can be run as <code>phaser run examples/mos2_grad.yaml</code> (for example).</p>"},{"location":"#alternatives","title":"Alternatives","text":"<p>Other notable ptychography packages:</p> <ul> <li><code>fold_slice</code> branch of PtychoShelves</li> <li><code>py4DSTEM</code></li> <li><code>PtyLab.m/py/jl</code></li> <li>PtyPy</li> <li>PtyRAD</li> </ul>"},{"location":"api/state/","title":"phaser.state","text":""},{"location":"api/state/#phaser.state","title":"phaser.state","text":""},{"location":"api/state/#phaser.state.Patterns","title":"Patterns","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass\nclass Patterns():\n    patterns: NDArray[numpy.floating]\n    \"\"\"Raw diffraction patterns, with 0-frequency sample in corner\"\"\"\n    pattern_mask: NDArray[numpy.floating]\n    \"\"\"Mask indicating which portions of the diffraction patterns contain data.\"\"\"\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            to_numpy(self.patterns), to_numpy(self.pattern_mask)\n        )\n</code></pre>"},{"location":"api/state/#phaser.state.Patterns.patterns","title":"patterns  <code>instance-attribute</code>","text":"<pre><code>patterns: NDArray[floating]\n</code></pre> <p>Raw diffraction patterns, with 0-frequency sample in corner</p>"},{"location":"api/state/#phaser.state.Patterns.pattern_mask","title":"pattern_mask  <code>instance-attribute</code>","text":"<pre><code>pattern_mask: NDArray[floating]\n</code></pre> <p>Mask indicating which portions of the diffraction patterns contain data.</p>"},{"location":"api/state/#phaser.state.Patterns.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        to_numpy(self.patterns), to_numpy(self.pattern_mask)\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.IterState","title":"IterState","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass\nclass IterState():\n    engine_num: int\n    \"\"\"Engine number. 1-indexed (0 means before any reconstruction).\"\"\"\n    engine_iter: int\n    \"\"\"Iteration number on this engine. 1-indexed (0 means before any iterations).\"\"\"\n    total_iter: int\n    \"\"\"Total iteration number. 1-indexed (0 means before any iterations).\"\"\"\n\n    n_engine_iters: t.Optional[int] = None\n    \"\"\"Total number of iterations in this engine.\"\"\"\n    n_total_iters: t.Optional[int] = None\n    \"\"\"Total number of iterations in the reconstruction.\"\"\"\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            int(self.engine_num), int(self.engine_iter), int(self.total_iter),\n            int(self.n_engine_iters) if self.n_engine_iters else None,\n            int(self.n_total_iters) if self.n_total_iters else None,\n        )\n\n    def copy(self) -&gt; Self:\n        import copy\n        return copy.deepcopy(self)\n\n    @staticmethod\n    def empty() -&gt; 'IterState':\n        return IterState(0, 0, 0)\n</code></pre>"},{"location":"api/state/#phaser.state.IterState.engine_num","title":"engine_num  <code>instance-attribute</code>","text":"<pre><code>engine_num: int\n</code></pre> <p>Engine number. 1-indexed (0 means before any reconstruction).</p>"},{"location":"api/state/#phaser.state.IterState.engine_iter","title":"engine_iter  <code>instance-attribute</code>","text":"<pre><code>engine_iter: int\n</code></pre> <p>Iteration number on this engine. 1-indexed (0 means before any iterations).</p>"},{"location":"api/state/#phaser.state.IterState.total_iter","title":"total_iter  <code>instance-attribute</code>","text":"<pre><code>total_iter: int\n</code></pre> <p>Total iteration number. 1-indexed (0 means before any iterations).</p>"},{"location":"api/state/#phaser.state.IterState.n_engine_iters","title":"n_engine_iters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_engine_iters: Optional[int] = None\n</code></pre> <p>Total number of iterations in this engine.</p>"},{"location":"api/state/#phaser.state.IterState.n_total_iters","title":"n_total_iters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_total_iters: Optional[int] = None\n</code></pre> <p>Total number of iterations in the reconstruction.</p>"},{"location":"api/state/#phaser.state.IterState.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        int(self.engine_num), int(self.engine_iter), int(self.total_iter),\n        int(self.n_engine_iters) if self.n_engine_iters else None,\n        int(self.n_total_iters) if self.n_total_iters else None,\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.IterState.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def copy(self) -&gt; Self:\n    import copy\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.IterState.empty","title":"empty  <code>staticmethod</code>","text":"<pre><code>empty() -&gt; IterState\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>@staticmethod\ndef empty() -&gt; 'IterState':\n    return IterState(0, 0, 0)\n</code></pre>"},{"location":"api/state/#phaser.state.ProbeState","title":"ProbeState","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass(static_fields=('sampling',))\nclass ProbeState():\n    sampling: Sampling\n    \"\"\"Probe coordinate system. See `Sampling` for more details.\"\"\"\n    data: NDArray[numpy.complexfloating]\n    \"\"\"Probe wavefunction, in realspace. Shape (modes, y, x)\"\"\"\n\n    def resample(\n        self, new_samp: Sampling,\n        rotation: float = 0.0,\n        order: int = 1,\n        mode: '_BoundaryMode' = 'grid-constant',\n    ) -&gt; Self:\n        new_data = self.sampling.resample(\n            self.data, new_samp,\n            rotation=rotation,\n            order=order,\n            mode=mode,\n        )\n        return self.__class__(new_samp, new_data)\n\n    def to_xp(self, xp: t.Any) -&gt; Self:\n        return self.__class__(\n            self.sampling, xp.array(self.data)\n        )\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            self.sampling, to_numpy(self.data)\n        )\n\n    def copy(self) -&gt; Self:\n        import copy\n        return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.ProbeState.sampling","title":"sampling  <code>instance-attribute</code>","text":"<pre><code>sampling: Sampling\n</code></pre> <p>Probe coordinate system. See <code>Sampling</code> for more details.</p>"},{"location":"api/state/#phaser.state.ProbeState.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: NDArray[complexfloating]\n</code></pre> <p>Probe wavefunction, in realspace. Shape (modes, y, x)</p>"},{"location":"api/state/#phaser.state.ProbeState.resample","title":"resample","text":"<pre><code>resample(\n    new_samp: Sampling,\n    rotation: float = 0.0,\n    order: int = 1,\n    mode: _BoundaryMode = \"grid-constant\",\n) -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def resample(\n    self, new_samp: Sampling,\n    rotation: float = 0.0,\n    order: int = 1,\n    mode: '_BoundaryMode' = 'grid-constant',\n) -&gt; Self:\n    new_data = self.sampling.resample(\n        self.data, new_samp,\n        rotation=rotation,\n        order=order,\n        mode=mode,\n    )\n    return self.__class__(new_samp, new_data)\n</code></pre>"},{"location":"api/state/#phaser.state.ProbeState.to_xp","title":"to_xp","text":"<pre><code>to_xp(xp: Any) -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_xp(self, xp: t.Any) -&gt; Self:\n    return self.__class__(\n        self.sampling, xp.array(self.data)\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ProbeState.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        self.sampling, to_numpy(self.data)\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ProbeState.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def copy(self) -&gt; Self:\n    import copy\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.ObjectState","title":"ObjectState","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass(static_fields=('sampling',))\nclass ObjectState():\n    sampling: ObjectSampling\n    \"\"\"Object coordinate system. See `ObjectSampling` for more details.\"\"\"\n    data: NDArray[numpy.complexfloating]\n    \"\"\"Object wavefunction. Shape (z, y, x)\"\"\"\n    thicknesses: NDArray[numpy.floating]\n    \"\"\"\n    Slice thicknesses (in length units).\n    Length &lt; 2 for single slice, equal to the number of slices otherwise.\n    \"\"\"\n\n    def to_xp(self, xp: t.Any) -&gt; Self:\n        return self.__class__(\n            self.sampling, xp.array(self.data), xp.array(self.thicknesses)\n        )\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            self.sampling, to_numpy(self.data), to_numpy(self.thicknesses)\n        )\n\n    def zs(self) -&gt; NDArray[numpy.floating]:\n        xp = get_array_module(self.thicknesses)\n        if len(self.thicknesses) &lt; 2:\n            return xp.array([0.], dtype=self.thicknesses.dtype)\n        return xp.cumsum(self.thicknesses) - self.thicknesses\n\n    def copy(self) -&gt; Self:\n        import copy\n        return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.ObjectState.sampling","title":"sampling  <code>instance-attribute</code>","text":"<pre><code>sampling: ObjectSampling\n</code></pre> <p>Object coordinate system. See <code>ObjectSampling</code> for more details.</p>"},{"location":"api/state/#phaser.state.ObjectState.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: NDArray[complexfloating]\n</code></pre> <p>Object wavefunction. Shape (z, y, x)</p>"},{"location":"api/state/#phaser.state.ObjectState.thicknesses","title":"thicknesses  <code>instance-attribute</code>","text":"<pre><code>thicknesses: NDArray[floating]\n</code></pre> <p>Slice thicknesses (in length units). Length &lt; 2 for single slice, equal to the number of slices otherwise.</p>"},{"location":"api/state/#phaser.state.ObjectState.to_xp","title":"to_xp","text":"<pre><code>to_xp(xp: Any) -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_xp(self, xp: t.Any) -&gt; Self:\n    return self.__class__(\n        self.sampling, xp.array(self.data), xp.array(self.thicknesses)\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ObjectState.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        self.sampling, to_numpy(self.data), to_numpy(self.thicknesses)\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ObjectState.zs","title":"zs","text":"<pre><code>zs() -&gt; NDArray[floating]\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def zs(self) -&gt; NDArray[numpy.floating]:\n    xp = get_array_module(self.thicknesses)\n    if len(self.thicknesses) &lt; 2:\n        return xp.array([0.], dtype=self.thicknesses.dtype)\n    return xp.cumsum(self.thicknesses) - self.thicknesses\n</code></pre>"},{"location":"api/state/#phaser.state.ObjectState.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def copy(self) -&gt; Self:\n    import copy\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.ProgressState","title":"ProgressState","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass\nclass ProgressState:\n    iters: NDArray[numpy.integer]\n    \"\"\"Iterations error measurements were taken at.\"\"\"\n    detector_errors: NDArray[numpy.floating]\n    \"\"\"Detector error measurements at those iterations\"\"\"\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            to_numpy(self.iters), to_numpy(self.detector_errors)\n        )\n\n    def copy(self) -&gt; Self:\n        import copy\n        return copy.deepcopy(self)\n\n    @staticmethod\n    def empty() -&gt; 'ProgressState':\n        return ProgressState(\n            numpy.array([], dtype=numpy.uint64),\n            numpy.array([], dtype=numpy.float64),\n        )\n\n    # TODO: this is a hack to prevent JIT recompilation.\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    def __eq__(self, other: t.Any) -&gt; bool:\n        if type(self) is not type(other):\n            return False\n        xp = get_array_module(self.iters, other.iters)\n        return (\n            xp.array_equal(self.iters, other.iters) and\n            xp.array_equal(self.detector_errors, other.detector_errors)\n        )\n</code></pre>"},{"location":"api/state/#phaser.state.ProgressState.iters","title":"iters  <code>instance-attribute</code>","text":"<pre><code>iters: NDArray[integer]\n</code></pre> <p>Iterations error measurements were taken at.</p>"},{"location":"api/state/#phaser.state.ProgressState.detector_errors","title":"detector_errors  <code>instance-attribute</code>","text":"<pre><code>detector_errors: NDArray[floating]\n</code></pre> <p>Detector error measurements at those iterations</p>"},{"location":"api/state/#phaser.state.ProgressState.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        to_numpy(self.iters), to_numpy(self.detector_errors)\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ProgressState.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def copy(self) -&gt; Self:\n    import copy\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.ProgressState.empty","title":"empty  <code>staticmethod</code>","text":"<pre><code>empty() -&gt; ProgressState\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>@staticmethod\ndef empty() -&gt; 'ProgressState':\n    return ProgressState(\n        numpy.array([], dtype=numpy.uint64),\n        numpy.array([], dtype=numpy.float64),\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState","title":"ReconsState","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass(kw_only=True, static_fields=('progress',))\nclass ReconsState:\n    iter: IterState\n    wavelength: Float\n\n    probe: ProbeState\n    object: ObjectState\n    scan: NDArray[numpy.floating]\n    \"\"\"Scan coordinates (y, x), in length units. Shape (..., 2)\"\"\"\n    tilt: t.Optional[NDArray[numpy.floating]] = None\n    \"\"\"Tilt angles (y, x) per scan position, in mrad. Shape (..., 2)\"\"\"\n    progress: ProgressState\n\n    def to_xp(self, xp: t.Any) -&gt; Self:\n        return self.__class__(\n            iter=self.iter,\n            probe=self.probe.to_xp(xp),\n            object=self.object.to_xp(xp),\n            scan=xp.array(self.scan),\n            tilt=None if self.tilt is None else xp.array(self.tilt),\n            progress=self.progress,\n            wavelength=self.wavelength,\n        )\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            iter=self.iter.to_numpy(),\n            probe=self.probe.to_numpy(),\n            object=self.object.to_numpy(),\n            scan=to_numpy(self.scan),\n            tilt=None if self.tilt is None else to_numpy(self.tilt),\n            progress=self.progress.to_numpy(),\n            wavelength=float(self.wavelength),\n        )\n\n    def copy(self) -&gt; Self:\n        import copy\n        return copy.deepcopy(self)\n\n    def write_hdf5(self, file: 'HdfLike'):\n        from phaser.utils.io import hdf5_write_state\n        hdf5_write_state(self, file)\n\n    @staticmethod\n    def read_hdf5(file: 'HdfLike') -&gt; 'ReconsState':\n        from phaser.utils.io import hdf5_read_state\n        return hdf5_read_state(file).to_complete()\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.iter","title":"iter  <code>instance-attribute</code>","text":"<pre><code>iter: IterState\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.wavelength","title":"wavelength  <code>instance-attribute</code>","text":"<pre><code>wavelength: Float\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.probe","title":"probe  <code>instance-attribute</code>","text":"<pre><code>probe: ProbeState\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.object","title":"object  <code>instance-attribute</code>","text":"<pre><code>object: ObjectState\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.scan","title":"scan  <code>instance-attribute</code>","text":"<pre><code>scan: NDArray[floating]\n</code></pre> <p>Scan coordinates (y, x), in length units. Shape (..., 2)</p>"},{"location":"api/state/#phaser.state.ReconsState.tilt","title":"tilt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tilt: Optional[NDArray[floating]] = None\n</code></pre> <p>Tilt angles (y, x) per scan position, in mrad. Shape (..., 2)</p>"},{"location":"api/state/#phaser.state.ReconsState.progress","title":"progress  <code>instance-attribute</code>","text":"<pre><code>progress: ProgressState\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.to_xp","title":"to_xp","text":"<pre><code>to_xp(xp: Any) -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_xp(self, xp: t.Any) -&gt; Self:\n    return self.__class__(\n        iter=self.iter,\n        probe=self.probe.to_xp(xp),\n        object=self.object.to_xp(xp),\n        scan=xp.array(self.scan),\n        tilt=None if self.tilt is None else xp.array(self.tilt),\n        progress=self.progress,\n        wavelength=self.wavelength,\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        iter=self.iter.to_numpy(),\n        probe=self.probe.to_numpy(),\n        object=self.object.to_numpy(),\n        scan=to_numpy(self.scan),\n        tilt=None if self.tilt is None else to_numpy(self.tilt),\n        progress=self.progress.to_numpy(),\n        wavelength=float(self.wavelength),\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def copy(self) -&gt; Self:\n    import copy\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.write_hdf5","title":"write_hdf5","text":"<pre><code>write_hdf5(file: HdfLike)\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def write_hdf5(self, file: 'HdfLike'):\n    from phaser.utils.io import hdf5_write_state\n    hdf5_write_state(self, file)\n</code></pre>"},{"location":"api/state/#phaser.state.ReconsState.read_hdf5","title":"read_hdf5  <code>staticmethod</code>","text":"<pre><code>read_hdf5(file: HdfLike) -&gt; ReconsState\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>@staticmethod\ndef read_hdf5(file: 'HdfLike') -&gt; 'ReconsState':\n    from phaser.utils.io import hdf5_read_state\n    return hdf5_read_state(file).to_complete()\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState","title":"PartialReconsState","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass(kw_only=True, static_fields=('progress',))\nclass PartialReconsState:\n    iter: t.Optional[IterState] = None\n    wavelength: t.Optional[Float] = None\n\n    probe: t.Optional[ProbeState] = None\n    object: t.Optional[ObjectState] = None\n    scan: t.Optional[NDArray[numpy.floating]] = None\n    \"\"\"Scan coordinates (y, x), in length units. Shape (..., 2)\"\"\"\n    tilt: t.Optional[NDArray[numpy.floating]] = None\n    progress: t.Optional[ProgressState] = None\n\n    def to_numpy(self) -&gt; Self:\n        return self.__class__(\n            iter=self.iter.to_numpy() if self.iter is not None else None,\n            probe=self.probe.to_numpy() if self.probe is not None else None,\n            object=self.object.to_numpy() if self.object is not None else None,\n            scan=to_numpy(self.scan) if self.scan is not None else None,\n            tilt=to_numpy(self.tilt) if self.tilt is not None else None,\n            progress=self.progress.to_numpy() if self.progress is not None else None,\n            wavelength=float(self.wavelength) if self.wavelength is not None else None,\n        )\n\n    def to_complete(self) -&gt; ReconsState:\n        missing = tuple(filter(lambda k: getattr(self, k) is None, ('probe', 'object', 'scan', 'wavelength')))\n        if len(missing):\n            raise ValueError(f\"ReconsState missing {', '.join(map(repr, missing))}\")\n\n        progress = self.progress if self.progress is not None else ProgressState.empty()\n        iter = self.iter if self.iter is not None else IterState.empty()\n\n        return ReconsState(\n            wavelength=t.cast(Float, self.wavelength),\n            probe=t.cast(ProbeState, self.probe),\n            object=t.cast(ObjectState, self.object),\n            scan=t.cast(NDArray[numpy.floating], self.scan),\n            tilt=self.tilt, progress=progress, iter=iter,\n        )\n\n    def write_hdf5(self, file: 'HdfLike'):\n        from phaser.utils.io import hdf5_write_state\n        hdf5_write_state(self, file)\n\n    @staticmethod\n    def read_hdf5(file: 'HdfLike') -&gt; 'PartialReconsState':\n        from phaser.utils.io import hdf5_read_state\n        return hdf5_read_state(file)\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.iter","title":"iter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iter: Optional[IterState] = None\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.wavelength","title":"wavelength  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wavelength: Optional[Float] = None\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.probe","title":"probe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>probe: Optional[ProbeState] = None\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.object","title":"object  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>object: Optional[ObjectState] = None\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.scan","title":"scan  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scan: Optional[NDArray[floating]] = None\n</code></pre> <p>Scan coordinates (y, x), in length units. Shape (..., 2)</p>"},{"location":"api/state/#phaser.state.PartialReconsState.tilt","title":"tilt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tilt: Optional[NDArray[floating]] = None\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.progress","title":"progress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>progress: Optional[ProgressState] = None\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; Self\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_numpy(self) -&gt; Self:\n    return self.__class__(\n        iter=self.iter.to_numpy() if self.iter is not None else None,\n        probe=self.probe.to_numpy() if self.probe is not None else None,\n        object=self.object.to_numpy() if self.object is not None else None,\n        scan=to_numpy(self.scan) if self.scan is not None else None,\n        tilt=to_numpy(self.tilt) if self.tilt is not None else None,\n        progress=self.progress.to_numpy() if self.progress is not None else None,\n        wavelength=float(self.wavelength) if self.wavelength is not None else None,\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.to_complete","title":"to_complete","text":"<pre><code>to_complete() -&gt; ReconsState\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def to_complete(self) -&gt; ReconsState:\n    missing = tuple(filter(lambda k: getattr(self, k) is None, ('probe', 'object', 'scan', 'wavelength')))\n    if len(missing):\n        raise ValueError(f\"ReconsState missing {', '.join(map(repr, missing))}\")\n\n    progress = self.progress if self.progress is not None else ProgressState.empty()\n    iter = self.iter if self.iter is not None else IterState.empty()\n\n    return ReconsState(\n        wavelength=t.cast(Float, self.wavelength),\n        probe=t.cast(ProbeState, self.probe),\n        object=t.cast(ObjectState, self.object),\n        scan=t.cast(NDArray[numpy.floating], self.scan),\n        tilt=self.tilt, progress=progress, iter=iter,\n    )\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.write_hdf5","title":"write_hdf5","text":"<pre><code>write_hdf5(file: HdfLike)\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>def write_hdf5(self, file: 'HdfLike'):\n    from phaser.utils.io import hdf5_write_state\n    hdf5_write_state(self, file)\n</code></pre>"},{"location":"api/state/#phaser.state.PartialReconsState.read_hdf5","title":"read_hdf5  <code>staticmethod</code>","text":"<pre><code>read_hdf5(file: HdfLike) -&gt; PartialReconsState\n</code></pre> Source code in <code>phaser/state.py</code> <pre><code>@staticmethod\ndef read_hdf5(file: 'HdfLike') -&gt; 'PartialReconsState':\n    from phaser.utils.io import hdf5_read_state\n    return hdf5_read_state(file)\n</code></pre>"},{"location":"api/state/#phaser.state.PreparedRecons","title":"PreparedRecons","text":"Source code in <code>phaser/state.py</code> <pre><code>@jax_dataclass(static_fields=('name', 'observer'))\nclass PreparedRecons:\n    patterns: Patterns\n    state: ReconsState\n    name: str\n    observer: 'ObserverSet'\n</code></pre>"},{"location":"api/state/#phaser.state.PreparedRecons.patterns","title":"patterns  <code>instance-attribute</code>","text":"<pre><code>patterns: Patterns\n</code></pre>"},{"location":"api/state/#phaser.state.PreparedRecons.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: ReconsState\n</code></pre>"},{"location":"api/state/#phaser.state.PreparedRecons.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/state/#phaser.state.PreparedRecons.observer","title":"observer  <code>instance-attribute</code>","text":"<pre><code>observer: ObserverSet\n</code></pre>"},{"location":"using/algorithms/","title":"Algorithm details","text":""},{"location":"using/algorithms/#theory-of-ptychography","title":"Theory of ptychography","text":"<p>Ptychography is an inverse problem where, given a series of diffraction patterns taken under shifted illumination, we attempt to reconstruct the experimental conditions 'most likely' to give us those diffraction patterns. These diffraction patterns are most often collected on a pixellated camera, but can also be collected with a segmented detector.</p> <p>In general, we have three variables in ptychography:</p> <ul> <li>The 'probe' \\(P\\), a complex field variable indicating the amplitude and phase of the incident wavefunction. In the case of mixed-state ptychography, we have a set of mutually incoherent probes \\(P_k\\), which we call 'probe modes'.</li> <li>The 'object' \\(O\\), which imparts a phase shift and attenuation to the wavefunction. The object can be two dimensional or three dimensional, in which case slices are separated by gaps of thickness \\(\\Delta z_i\\). In electron microscopy, the object slices are sometimes referred to as \"transmission functions\".</li> <li>Probe positions \\(X_j\\). For each position, the probe is shifted to that location and a diffraction pattern taken.</li> </ul> <p>Our forward model is the multislice method, which is capable of modeling interaction with a thick specimen as well as multiple scattering. Given a set of probe modes \\(P_k\\), a 3D object \\(O_i\\), and a probe position \\(P_j\\), we iteratively calculate the wavefunction at each slice given the wavefunction at the slice before:</p> \\[\\begin{aligned} \\Psi_{0,k}(\\vec{r}) &amp;= P_k(\\vec{r} - X_j) \\\\ \\Psi_{i+1,k}(\\vec{r}) &amp;= (\\Psi_{i,k}(\\vec{r}) \\cdot O_i(\\vec{r})) * p(\\Delta z_i) \\end{aligned}\\] <p>In the above, \\(p(\\Delta z)\\) indicates a Fresnel free-space propagation kernel of distance \\(\\Delta z\\), which is convolved with the wavefunction.</p> <p>Finally, given the exit wavefunction \\(\\Psi_{n,k}\\), we calculate the final intensity in reciprocal space:</p> \\[ I(\\vec{k}) = \\sum_{k} \\left| \\mathcal{F}(\\Psi_{n, k})(\\vec{k}) \\right|^2 \\] <p>The inverse problem consists of taking measured diffraction patterns \\(I_exp\\) and recovering the probe \\(P\\) and object \\(O\\). In the case of single-slice ptychography (where the object is 2D), and the probe positions \\(P_j\\) are perfectly known (and do not fall onto a perfect raster grid), the solution is unambiguous up to a scaling factor of intensity and an affine phase ramp of the object [5]. In practice, the probe positions \\(P_j\\) are not known perfectly, and initial estimates are updated as the algorithm proceeds. This can introduce additional ambiguity, as in the geometrical optics limit, a change in first order aberrations is equivalent to a linear transformation of the probe positions [4].</p>"},{"location":"using/algorithms/#noise-models","title":"Noise models","text":"<p>Ptychography is an overdetermined nonlinear inverse problem. Because the problem is overdetermined, the vast majority of experimental data has no exact solution; any experimental noise whatsoever will likely perturb the problem into this region. This is overcome by the use of maximum likelihood estimation; rather than attempting to find an exact solution, we attempt to find the probe and object 'most likely' to generate the recorded data under some noise model.</p> <p>The choice of noise model in ptychography has been well-covered in the literature [19,12,18]. Given a modeled intensity \\(I(\\vec{k})\\) and a measured intensity \\(I_{exp}(\\vec{k})\\), we desire to maximize the probability \\(P(I | I_{exp})\\), i.e. we would like to find the most likely intensity given the experimental data. This is known as the maximum a posteriori estimate. This probability can be obtained using Bayes' theorem:</p> \\[ P(I | I_{exp}) = \\frac{P(I_{exp} | I) P(I)}{P(I_{exp})} \\] <p>However, we usually lack good estimates of the prior probabilities \\(P(I)\\). Using a uniform prior distribution of \\(P(I)\\), maximizing \\(P(I | I_{exp})\\) is equivalent to maximizing the likelihood \\(P(I_{exp} | I)\\):</p> \\[ \\max_{I} P(I_{exp} | I) = \\max_{I} \\prod_{\\vec{k}} P(I(\\vec{k}) | I_{exp}(\\vec{k})) \\\\ \\] <p>The Gauss-Markov theorem shows that when noise is independent and of constant variance, least squares is the best unbiased linear estimator. We show the maximum-likelihood solution in the case of Gaussian noise of variance \\(\\sigma^2\\):</p> \\[\\begin{aligned} P(I | I_{exp}) &amp;= \\prod_{\\vec{k}} \\frac{1}{\\sigma \\sqrt{2 \\pi}} \\exp \\frac{-(I(\\vec{k}) - I_{exp}(\\vec{k}))^2}{2 \\sigma^2} \\\\ \\mathcal{L}(I) = - \\log P(I | I_{exp}) &amp;= \\sum_{\\vec{k}} \\frac{1}{2 \\sigma^2} \\left( I(\\vec{k}) - I_{exp}(\\vec{k}) \\right)^2 + \\log \\left( \\sigma \\sqrt{2 \\pi} \\right) \\end{aligned}\\] <p>As is customary, we define the loss function \\(\\mathcal{L}(I)\\) as the negative log-likelihood. The second term above is a normalization constant and can be ignored.</p> <p>In the case of Poisson noise, variance is not constant, but scales with mean intensity. The maximum likelihood solution is:</p> \\[\\begin{aligned} P(I | I_{exp}) &amp;= \\prod_{\\vec{k}} \\frac{I(\\vec{k})^{I_{exp}(\\vec{k})} e^{-I(\\vec{k})}}{I_{exp}(\\vec{k})!} \\\\ \\mathcal{L}(I) &amp;= \\sum_{\\vec{k}} I(\\vec{k}) - I_{exp}(\\vec{k}) \\log I(\\vec{k}) + \\log\\left(I_{exp}(\\vec{k})!\\right) \\\\ \\mathcal{L}(I) &amp;\\approx \\sum_{\\vec{k}} \\left(I(\\vec{k}) - I_{exp}(\\vec{k})\\right) - I_{exp}(\\vec{k}) \\left( \\log I(\\vec{k}) - \\log I_{exp}(\\vec{k}) \\right) \\end{aligned}\\] <p>where at the last step we have applied Stirling's approximation. In practice, a small offset \\(\\epsilon\\) must be added to prevent divergences inside the logarithms. This epsilon can be rationalized as a minimum signal recognizable by the detector. Setting this value high (e.g. 0.1 \\(e^-\\)) has the effect of ignoring updates from weak-intensity areas.</p> <p>When counts are moderate, a variance stabilizing transform can be applied to Poisson distributed data to be approximately Gaussian with a constant variance, allowing the use of a least-squares estimator. This leads to the amplitude and Anscombe noise models. Given a transformation \\(x \\mapsto 2 \\sqrt{x + c}\\), we can model the transformed variable as Gaussian with variance 1:</p> \\[\\begin{aligned} \\mathcal{L}(I) = \\sum_{\\vec{k}} \\frac{1}{2} \\left( \\sqrt{I(\\vec{k}) + c} - \\sqrt{I_{exp}(\\vec{k}) + c} \\right)^2 \\end{aligned}\\] <p>\\(c = 0\\) leads to the amplitude noise model, while \\(c = 3/8\\) leads to the Anscombe noise model. The amplitude and Ascombe noise models have the benefit that additive Gaussian noise can be considered analytically, as discussed by Godard et al. [19].</p> <p>For the conventional engines, gradients of the loss functions are taken analytically:</p> \\[\\begin{aligned} \\nabla \\mathcal{L_{p}}(\\Psi) &amp;= \\left(1 - \\frac{I_{exp}(\\vec{k})}{\\epsilon + I(\\vec{k})} \\right) \\Psi(\\vec{k}) \\\\ \\nabla \\mathcal{L_{a}}(\\Psi) &amp;= \\left(1 - \\frac{\\sqrt{I_{exp}(\\vec{k}) + c}}{\\epsilon + \\sqrt{I(\\vec{k}) + c}} \\right) \\Psi(\\vec{k}) \\end{aligned}\\] <p>As noted by Leidl et al [18], these two gradients show significant differences in their spatial extent, with the Poisson gradient providing the largest updates at large scattering angles (where signals are weak).</p> <p>Using these gradients, an optimal step size can be calculated [12], and a total wavefunction update can be found as \\(\\Delta \\Psi(\\vec{k}) = - \\alpha \\nabla \\mathcal{L}(\\Psi)\\). For instance, for the amplitude/Anscome loss function:</p> \\[ \\Delta \\Psi(\\vec{k}) = \\frac{\\sqrt{I_{exp}(\\vec{k}) + c}}{\\epsilon + \\sqrt{I(\\vec{k}) + c}} \\Psi(\\vec{k}) - \\Psi(\\vec{k}) \\] <p>In the amplitude noise model, this corresponds to the classic modulus constraint of the ePIE method.</p>"},{"location":"using/algorithms/#detailed-description-of-engines","title":"Detailed description of engines","text":""},{"location":"using/algorithms/#gradient-descent","title":"Gradient descent","text":"<p>The gradient descent engine employs traditional machine learning algorithms to fit the system to the experimental data, minimizing the loss function \\(\\mathcal{L}\\). Autodifferentiation is used to obtain the gradients \\(\\nabla \\mathcal{L}\\). Since the loss function \\(\\mathcal{L}\\) is a non-constant real function, it is not holomorphic. However, Wirtinger derivatives can be used [13] to overcome this challenge. For real functions, the two Wirtinger derivatives are equivalent:</p> \\[ \\overline{\\frac{\\partial f}{\\partial z}} = \\frac{\\partial f}{\\partial \\tilde{z}} \\] <p>And the gradient \\(\\mathbb{R} \\to \\mathbb{C}\\) can be taken as:</p> \\[ \\nabla \\mathcal{L} = \\overline{\\frac{\\partial \\mathcal{L}}{\\partial z}} \\] <p>With the gradient descent engine, solvers can be specified per reconstruction variable in a dictionary.</p> <pre><code>type: 'gradient'\n\nsolvers:\n  object:\n    type: 'sgd'\n    learning_rate: 1.0e+0\n    momentum: 0.9\n  probe:\n    type: 'adam'\n    learning_rate: 1.0e+1\n</code></pre> <p>In the above example, the object is updated using stochastic gradient descent (SGD) with Nesterov momentum [20], while the probe is updated using adaptive moment estimation (Adam) [21]. Both of these solvers are commonly used in machine learning. Another solver option is SGD with a step size given by a Polyak-Ribere conjugate gradient algorithm [22].</p> <p>Regularizations can be specified in two main forms: Costs which are added to the loss function \\(\\mathcal{L}\\) per group, and as constraints which are applied per-group or per-iteration. Costs are specified in units of electrons\u2014equivalent to one electron on the wrong place of the detector.</p> <p>Below are some example regularizations:</p> <pre><code>regularizations:  # cost regularizations, applied per group\n  - type: obj_l1  # L1 regularization of object\n    cost: 15.0\n\ngroup_constraints:  # constraints, applied per group\n  - type: clamp_object_amplitude\n    amplitude: 1.1\n\niter_constraints:  # constraints, applied per iteration\n  - type: layers  # low-pass filter object in Z direction\n    sigma: 50.0\n</code></pre>"},{"location":"using/algorithms/#conventional-engines","title":"Conventional engines","text":"<p>Along with the gradient descent engine, phaser implements two conventional ptychography algorithms, ePIE and LSQML. The key difference between the gradient descent engine and the conventional engines is that, in the context of multislice ptychography, the conventional engines form an estimate of the optimized wavefront \\(\\Psi\\) at the detector and on each layer. This optimized \\(\\Psi\\) is used while calculating the gradient of the previous step. In contrast, in the gradient descent engine, the gradients are all taken simultaneously, and a step is taken in the direciton of the gradient. </p>"},{"location":"using/algorithms/#epie","title":"ePIE","text":"<p>In the ePIE algorithm, we first use the noise model to compute a wavefront update \\(\\chi(\\vec{k})\\) on the detector, and backwards propagate it to the exit plane of the sample. Then, at each slice, we split the wavefront update to the object slice and to the previous wavefront/probe:</p> \\[\\begin{aligned} \\chi_{n}(\\vec{r}) &amp;= \\mathcal{F}^{-1}(\\chi(\\vec{k})) \\\\ \\chi_{i-1} &amp;= \\frac{O_i^*(\\vec{r})}{\\max_{\\vec{r}} \\left| O_i(\\vec{r}) \\right|^2} \\chi_i(\\vec{r}) \\\\ \\Delta O_i &amp;= \\frac{P_i^*(\\vec{r})}{\\max_{\\vec{r}} \\left| \\Psi_i(\\vec{r}) \\right|^2} \\chi_i(\\vec{r}) \\\\ \\end{aligned}\\] <p>Finally, we calculate the updates to the probe and object. Probe updates are averaged across the group/batch of positions, while object updates are summed across the group:</p> \\[\\begin{aligned} P(\\vec{r}) &amp;\\mathrel{+}= \\beta_{probe} \\frac{\\sum_{k} \\chi_{0,k}(\\vec{r})}{N_k} \\\\ O_i(\\vec{r}) &amp;\\mathrel{+}= \\beta_{object} \\sum_{k} \\Delta O_{i,k}(\\vec{r}) \\end{aligned}\\] <p>This multislice generalization of ePIE (sometimes called 3PIE) was introduced by Maiden et al [8] and is further discussed by Tsai et al [11]. We recognize \\(O^*(\\vec{r})\\) as the Wirtinger derivative \\(\\frac{\\partial}{\\partial \\tilde{z}}\\) of \\(P O\\) with respect to \\(P\\), showing that single-slice ePIE can be considered a gradient descent method. For multislice, 3PIE diverges from pure gradient descent in that an update step is taken each slice, prior to the backpropagation of gradients to the previous slice.</p> <p>In <code>phaser</code>, the ePIE solver can be specified as follows:</p> <pre><code># inside engine\ntype: 'conventional'\nnoise_model: 'amplitude'  # for instance\n\nsolver:\n  type: epie\n  # parameters, as described above\n  beta_object: 0.1\n  beta_probe: 0.1\n</code></pre>"},{"location":"using/algorithms/#lsqml","title":"LSQML","text":"<p>The LSQML method is implemented as described in Odstr\u010dil et al. [12]. In <code>phaser</code>, the LSQML solver can be specified as follows:</p> <pre><code># inside engine\ntype: 'conventional'\nnoise_model: 'amplitude'  # for instance\n\nsolver:\n  type: lsqml\n  # scaling of probe and object updates\n  beta_object: 0.1\n  beta_probe: 0.1\n\n  # gamma in [12]. eq. 23\n  gamma: 1.0e-4\n\n  # delta_P and delta_O in [12] eq. 25\n  illum_reg_object: 1.0e-2\n  illum_reg_probe: 1.0e-2\n</code></pre>"},{"location":"using/algorithms/#regularizations","title":"Regularizations","text":"<p>For the conventional engines, constraint-based regularizations are supported (<code>group_constraints</code> and <code>iter_constraints</code>) but not cost-based regularizations. </p>"},{"location":"using/algorithms/#position-solving","title":"Position solving","text":"<p>For the conventional engines, position solving is performed using the gradient of the loss with respect to a shift in probe position, scaled by the update step size. Two position solvers are supported, a steepest descent solver and a momentum-accelerated solver:</p> <pre><code>type: 'conventional'\nsolver: ...\n\nposition_solver:\n  type: 'momentum'  # or 'steepest_descent'\n  # can specify a maximum step size, in realspace units\n  max_step_size: ~\n  # fraction of optimal step size to take\n  step_size: 1.0e-2\n  # momentum decay rate\n  momentum: 0.9\n</code></pre>"},{"location":"using/algorithms/#references","title":"References","text":"<p>The following is an incomplete bibliograpy of relevant papers.</p>"},{"location":"using/algorithms/#theory-of-ptychography_1","title":"Theory of ptychography","text":"<p>[1] Lin, J. A. &amp; Cowley, J. M. Reconstruction from in-line electron holograms by digital processing. Ultramicroscopy 19, 179\u2013190 (1986).</p> <p>[2] Rodenburg, J. M. The phase problem, microdiffraction and wavelength-limited resolution \u2014 a discussion. Ultramicroscopy 27, 413\u2013422 (1989).</p> <p>[3] Rodenburg, J. M. Ptychography and Related Diffractive Imaging Methods. in Advances in Imaging and Electron Physics (ed. Hawkes) vol. 150 87\u2013184 (Elsevier, 2008).</p> <p>[4] Cao, S. Large Field of View Electron Ptychography. (University of Sheffield, 2017).</p> <p>[5] Fannjiang, A. Raster Grid Pathology and the Cure. Multiscale Model. Simul. 17, 973\u2013995 (2019).</p>"},{"location":"using/algorithms/#epie_1","title":"ePIE","text":"<p>[6] Maiden, A. M. &amp; Rodenburg, J. M. An improved ptychographical phase retrieval algorithm for diffractive imaging. Ultramicroscopy 109, 1256\u20131262 (2009).</p> <p>[7] Thibault, P., Dierolf, M., Bunk, O., Menzel, A. &amp; Pfeiffer, F. Probe retrieval in ptychographic coherent diffractive imaging. Ultramicroscopy 109, 338\u2013343 (2009).</p> <p>[8] Maiden, A. M., Humphry, M. J. &amp; Rodenburg, J. M. Ptychographic transmission microscopy in three dimensions using a multi-slice approach. Journal of the Optical Society of America A 29, 1606 (2012).</p>"},{"location":"using/algorithms/#lsqml_1","title":"LSQML","text":"<p>[9] Thibault, P. &amp; Guizar-Sicairos, M. Maximum-likelihood refinement for coherent diffractive imaging. New J. Phys. 14, 063004 (2012).</p> <p>[10] Thibault, P. &amp; Menzel, A. Reconstructing state mixtures from diffraction measurements. Nature 494, 68\u201371 (2013).</p> <p>[11] Tsai, E. H. R., Usov, I., Diaz, A., Menzel, A. &amp; Guizar-Sicairos, M. X-ray ptychography with extended depth of field. Opt. Express, OE 24, 29089\u201329108 (2016).</p> <p>[12] Odstr\u010dil, M., Menzel, A. &amp; Guizar-Sicairos, M. Iterative least-squares solver for generalized maximum-likelihood ptychography. Optics Express 26, 3108 (2018).</p>"},{"location":"using/algorithms/#gradient-descent_1","title":"Gradient descent","text":"<p>[13] Cand\u00e8s, E. J., Li, X. &amp; Soltanolkotabi, M. Phase Retrieval via Wirtinger Flow: Theory and Algorithms. IEEE Transactions on Information Theory 61, 1985\u20132007 (2015).</p> <p>[14] Ghosh, S., Nashed, Y. S. G., Cossairt, O. &amp; Katsaggelos, A. ADP: Automatic differentiation ptychography. in 2018 IEEE International Conference on Computational Photography (ICCP) 1\u201310 (2018). https://doi.org/10.1109/ICCPHOT.2018.8368470.</p> <p>[15] Xu, R. et al. Accelerated Wirtinger Flow: A fast algorithm for ptychography. Preprint at https://doi.org/10.48550/arXiv.1806.05546 (2018).</p> <p>[16] Kandel, S. et al. Using automatic differentiation as a general framework for ptychographic reconstruction. Opt. Express, OE 27, 18653\u201318672 (2019).</p> <p>[17] Schloz, M. et al. Overcoming information reduced data and experimentally uncertain parameters in ptychography with regularized optimization. Opt. Express, OE 28, 28306\u201328323 (2020).</p> <p>[18] Leidl, M. L., Diederichs, B., Sachse, C. &amp; M\u00fcller-Caspary, K. Influence of loss function and electron dose on ptychography of 2D materials using the Wirtinger flow. Micron 185, 103688 (2024).</p>"},{"location":"using/algorithms/#regularizationsnoise-modelssolvers","title":"Regularizations/noise models/solvers","text":"<p>[19] Godard, P., Allain, M., Chamard, V. &amp; Rodenburg, J. Noise models for low counting rate coherent diffraction imaging. Opt. Express, OE 20, 25914\u201325934 (2012).</p> <p>[20] Sutskever, I., Martens, J., Dahl, G. &amp; Hinton, G. On the importance of initialization and momentum in deep learning. in Proceedings of the 30th International Conference on Machine Learning 1139\u20131147 (PMLR, 2013).</p> <p>[21] Kingma, D. P. &amp; Ba, J. Adam: A Method for Stochastic Optimization. Preprint at https://doi.org/10.48550/arXiv.1412.6980 (2017).</p> <p>[22] Loizou, N., Vaswani, S., Laradji, I. &amp; Lacoste-Julien, S. Stochastic Polyak Step-size for SGD: An Adaptive Learning Rate for Fast Convergence. Preprint at https://doi.org/10.48550/arXiv.2002.10542 (2021).</p> <p>[23] Tanksalvala, M. et al. Nondestructive, high-resolution, chemically specific 3D nanostructure characterization using phase-sensitive EUV imaging reflectometry. Science Advances 7, eabd9667 (2021).</p>"},{"location":"using/conventions/","title":"Conventions &amp; glossary","text":""},{"location":"using/conventions/#units","title":"Units","text":"<p>The core ptychographic routines are unit-independent, so any units can be used. However, since this package is designed primarily for high-resolution electron ptychography, data is typically loaded and stored with length units of Angstrom (\\( 1 \\:\\mathrm{\\AA} = 10^{-10} \\:\\mathrm{m} \\)).  Other units typically follow SI base units.</p>"},{"location":"using/conventions/#coordinate-system","title":"Coordinate system","text":"<p>Images are stored row-major, starting with the top-left corner. Keeping with this, points are usually stored as <code>(y, x)</code> pairs. Raw data is changed to this convention on import.</p> <p>A right-handed coordinate system is used. Looking down the optic axis, the x-axis points right, the y-axis points down, and the z-axis points into the page (Forward propagation is the +z direction).</p> <p>In real-space, the origin is usually centered. In reciprocal space, the origin/zero-frequency point is at the top left corner. The exception is diffraction patterns, which are stored in their original orientation.</p> <p>Wavefields are stored so total intensity (\\(I\\)) is conserved in both spaces:</p> \\[\\begin{aligned} \\sum \\sum \\left| f(x, y) \\right|^2 &amp;= I \\\\ \\sum \\sum \\left| F(k_x, k_y) \\right|^2 &amp;= I \\\\ \\end{aligned}\\] <p>Typically, these intensities are kept in units of particles (electrons or photons). This scaling is critical for the Poisson noise model, and keeping the same scaling throughout allows object regularizations to have a stronger effect as dose decreases.</p> <p>Phase follows the convention where a plane wave is defined as \\(\\exp(2\\pi i (\\mathbf{k} \\cdot \\mathbf{r}))\\). This is the most common convention, equivalent to defining the Fourier transform as \\(F(\\mathbf{k}) = \\int f(\\mathbf{r}) \\exp(-2\\pi i (\\mathbf{k} \\cdot \\mathbf{r})) \\:d\\mathbf{r}\\). However, older crystallography literature uses an opposite sign convention. See Spence and Zuo [1] for more information. A positive defocus aberration is used to indicate overfocus.</p> <p>The helper functions <code>phaser.num.fft2</code> and <code>phaser.num.ifft2</code>, as well as <code>phaser.num.Sampling</code> help to enforce these conventions.</p> <p>[1] Spence, J. C.H. &amp; Zuo, J. M. Electron Microdiffraction. (Plenum Press, New York, 1992).</p>"},{"location":"using/plan/","title":"Reconstruction plan files","text":"<p>A 'plan' is a file specifying a series of reconstruction steps ('engines') to take. Plan files are specified in the YAML data specification language, to allow files to be easily read by both humans and machines.</p>"},{"location":"using/plan/#plan-options","title":"Plan options","text":"<p>A reconstruction plan has the following top-level keys:</p> <pre><code># name of reconstruction\nname: my_recons\n# (optional) computational backend to use, 'cupy', 'jax', 'numpy', or None (default)\nbackend: 'cupy'\n# (optional) datatype to perform reconstructions with 'float32' (default) or 'float64'\ndtype: float32\n\n# Hook to load raw data. See section below\nraw_data: ~\n\n# (optional) Sequence of hooks to run after loading data. See section below\npost_load: []\n\n# wavelength of radiation, in angstroms. Inferred from raw data if not specified\nwavelength: 0.0251\n\n# How to initialize probe, object, and probe positions\ninit:\n  probe: ~\n  object: ~\n  scan: ~\n\n# (optional) For multislice reconstructions, specify initial slices to use\nslices:\n  n: 20\n  total_thickness: 200  # can also specify `slice_thickness` instead\n\n# (optional) Sequence of hooks to run after initialization but before reconstructions\npost_init: []\n\n# list of engines to run in sequence\nengines: []\n</code></pre>"},{"location":"using/plan/#engine-plan-options","title":"Engine plan options","text":"<p>Each engine supports the following keys:</p> <pre><code># number of iterations to run\nniter: 100\n# (optional) number of probe positions to simulate simultaneously\ngrouping: 64\n# (optional) whether to group probe positions\n# compactly (as in LSQ-MLc) or sparsely (the default)\ncompact: False\n# (optional) flag indicating whether to shuffle groups at a given iteration.\n# Defaults to `True` if using sparse positions, `False` otherwise.\nshuffle_groups: True\n\n# (optional) size of simulation [n_y, n_x]\nsim_shape: [256, 256]\n# (optional) how to resize probe, object, and patterns to `sim_shape`.\n# 'pad_crop' (default) or 'resample'. `pad_crop` means patterns are\n# padded or cropped (and therefore real-space is resampled).\nresize_method: 'pad_crop'\n\n# (optional) Number of incoherent probe modes to simulate.\nprobe_modes: 4\n\n# (optional) flags indicating whether to update the object, probe,\n# or probe positions at a given iteration\nupdate_object: True\nupdate_probe: {after: 10}\nupdate_positions: {before: 80}\n\n# noise model to use for reconstruction.\nnoise_model: 'poisson'\n\n# (optional) flag indicating whether to calculate detector error\n# at a given iteration\ncalc_error: {every: 5}\n# (optional) fraction of groups to calculate error at\ncalc_error_fraction: 0.1\n\n# (optional) flag indicating whether to save output\n# at a given iteration\nsave: {every: 10}\nsave_images: {every: 10}\n\n# (optional) options for output\nsave_options:\n  # (optional) list of image types to save. Supports 'probe[_mag]',\n  # 'probe_recip[_mag]', 'object_(phase|mag)_(stack|sum)'\n  images: ['probe', 'probe_mag', 'object_phase_stack', 'object_mag_stack']\n  # (optional) whether to crop images to the scan bounding box\n  crop_roi: True\n  # (optional) whether to phase unwrap phase images\n  unwrap_phase: True\n  # (optional) Datatype to store images at. Floating point images\n  # are stored unscaled, other images are scaled to saturation\n  img_dtype: 16bit  # float, 8bit, 16bit, or 32bit\n\n  # (optional) Python format strings controlling the name of\n  # HDF5 and image outputs.\n  # 'name' is resolved to the name of the reconstruction, 'type'\n  # is the type of image, and 'iter' is an IterState object.\n  out_dir: \"{name}\"\n  img_fmt: \"{type}_iter{iter.total_iter}.tiff\"\n  hdf5_fmt: \"iter{iter.total_iter}.h5\"\n</code></pre>"},{"location":"using/plan/#hooks","title":"Hooks","text":"<p>A common theme throughout <code>phaser</code> is the use of 'hooks'. Hooks are modular components, customizable by the end user. For instance, <code>post_load</code> is passed a list of hooks, each of which can arbitrarily modify the raw data. Each hook type has a defined function signature, which all instances of that hook should obey. Hooks can also take properties, which are passed to the hook function for configuration.</p> <p>Here are some example hook instantiations: <pre><code>post_load:\n   # calls the built-in hook 'poisson'\n - 'poisson'      \n   # same as previous, but can specify properties as well\n - type: poisson   \n   scale: 1.0e+7\n   # call a user-defined hook 'function' from package 'user_package.subpkg'\n - user_package.subpkg:function\n   # same as previous, but pass properties as well\n - type: user_package.subpkg:function\n   myprop: value\n</code></pre></p> <p>Properties are type-checked for built-in hooks, but not user defined hooks. In the case of <code>post_load</code>, this is signature of each hook function:</p> <pre><code>def hook(args: RawData, props: t.Dict[str, t.Any]) -&gt; RawData:\n    ...\n</code></pre>"},{"location":"using/plan/#known-hooks","title":"Known hooks","text":"<p>Post-load hooks have an opportunity to modify the loaded raw data prior to state initialization. <pre><code>post_load:\n  # crop the raw data (in real space), (y_i, y_f, x_i, x_f). Python-like slicing\n  - type: crop_data\n    crop: [0, 50, 0, -10]\n  # scale the raw data by `scale`, then apply Poisson noise\n  - type: poisson\n    scale: 1.0e+7\n  # just scale the raw data\n  - type: scale\n    scale: 1.0e+4\n</code></pre></p> <p>Post-init hooks modify data after initialization but before reconstruction. They can modify the raw patterns, the state, or both.</p> <pre><code>post_init:\n  # drop patterns which are mostly NaNs. Flattens scan\n  - drop_nans\n  # diffraction align patterns (applies bilinear resampling)\n  - diffraction_align\n</code></pre> <p>Noise models are hooks as well. When called, they return an instance of <code>NoiseModel</code>. Noise models are discussed in more detail in the engines section.</p> <pre><code>noise_model:\n  - type: amplitude\n    eps: 1.0e-3\n  - anscombe\n  - poisson\n</code></pre> <p>Flags are hooks which return a boolean value each iteration:</p> <pre><code>engines:\n - niter: 100\n   # return True after 10 iterations, False before\n   update_probe: {after: 10}\n   # return True every 5 iterations\n   update_positions: {every: 5}\n   # return True every even iteration between 3 and 79\n   update_object: {after: 2, before: 80, every: 2}\n   # or call a user-defined hook\n   save_images: 'mypkg:user_defined_hook'\n</code></pre> <p>Solvers &amp; regularizers are hooks as well. These are discussed in more detail in the engines section.</p>"},{"location":"using/starting/","title":"Getting started","text":"<p><code>phaser</code> can be installed via <code>pip</code> or <code>conda</code> using the instructions found on the main page. To get started with reconstructions, download one of the sample datasets described here. Each sample dataset has an associated reconstruction plan file <code>plan.yaml</code>.</p> <p>To reconstruct, simply run  <pre><code>$ phaser run path/to/plan.yaml\n</code></pre></p>"}]}